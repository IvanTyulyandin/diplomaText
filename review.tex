\section{Обзор}
В этой главе будут рассмотрены среды исполнения и языки смарт-контрактов, а так же некоторые особенности \name{Hyperledger Iroha}.

\subsection{Языки и среды исполнения смарт-контрактов}
В 1997 году Ник Сабо (Nick Szabo) предложил концепцию смарт-контрактов~\cite{Szabo_SC}.
Смарт-контракт --- это программа, которая описывает взаимодействие участников блокчейн-сети. 
При сравнении с традиционным бумажным контрактом, смарт-контракт имеет однозначную семантику и выполняется автоматически при достижении определенных условий.
Результат выполнения смарт-контракта легко подтверждается, так как он будет записан в историю транзакций блокчейна.
На сегодняшний день существует множество различных языков смарт-контрактов и блокчейнов, которые могут исполнять программы на этих языках.

Смарт-контракт всегда должен завершаться для продолжения работы блокчейн-сети.
Если язык смарт-контрактов Тьюринг-полный, то среда исполнения должна предоставлять механизм, который будет ограничивать тем или иным способом количество операций смарт-контракта.
В случае \name{Ethereum} каждая инструкция стоит определенное количество \emph{газа}, цена которого выражена во внутренней криптовалюте \name{Et\-he\-re\-um}.
В \name{Hyperledger Fabric} имеется ограничение на время выполнения кода смарт-контракта.
Для языка \name{Rholang}~\cite{Rholang}, основанном на \name{Rho-calculus}~\cite{RhoCalculus}, выставляется лимит по количеству применений правил редукции.

Далее будут рассмотрены несколько сред исполнения смарт-кон\-трак\-тов и языки, которые данные среды поддерживают.

\subsubsection{Языки смарт-контрактов}
В этой подглаве рассмотрены языки смарт-контрактов с учетом их парадигм и свойств, таких как Тьюринг-полнота, механизм ограничения выполнения смарт-контракта платформой (на которой смарт-контракт исполняется) и системы типов.

На данный момент существуют языки смарт-контрактов с различным уровнем абстракции. 
\emph{Низкоуровневые языки} (low-level) предназначены для непосредственного выполнения средой исполнения.
Многие концепции, такие как семантика, вычислительная модель, система ограничения выполнения и типизация часто описываются на этом уровне.
Примеры таких языков --- \name{EVM}~\cite{EthereumYellowPaper}, \name{Bitcoin Script}~\cite{BitcoinScript} и \name{Michelson}~\cite{Michelson}.
\emph{Высокоуровневые языки} (high-level), такие как \name{Solidity}~\cite{Solidity}, \name{Flint}~\cite{Flint} и \name{Liquidity}~\cite{liquidity},
упрощают процесс разработки смарт-контрактов за счет повышенной читаемости, наличия более абстрактных синтаксических конструкций и системы типов.
\emph{Промежуточные языки} (intermediate-level) смарт-контрактов являются своего рода компромиссом между высокоуровневыми и низкоуровневыми языками по степени абстракции.
Как правило, они спроектированы для упрощения формальной верификации или статического анализа исходного кода (с учетом вычислительной модели, системы типов, семантики и других формализмов).
\name{Scilla}~\cite{Scilla} является промежуточным языком смарт-контрактов.

В ходе обзора языков смарт-контрактов на конференцию SYRCoSE 2019 была написана обзорная статья \emph{A Survey of Smart Contract Safety and Pro\-gram\-ming Languages}, которая будет опубликована в Proceedings of ISP RAS.
Ниже приведена сводная таблица по языкам смарт-кон\-трак\-тов и их свойствам из данной статьи.
В ней приведены следующие характеристики языков смарт-контрактов: название, уровень абстракции, текущее состояние разработки, проект (для которого язык предназначен), парадигма, способ ограничения выполнения смарт-контракта целевой платформой и Тьюринг-полнота соответственно. 


\begin{ThreePartTable}
\renewcommand\TPTminimum{\textwidth}
% Arrange for "longtable" to take up full width of text block
\setlength\LTleft{0pt}
\setlength\LTright{0pt}
\setlength\tabcolsep{0pt}
%\begin{TableNotes}
%\end{TableNotes}
\fontsize{11}{12}\selectfont
\begin{longtable}{  l @{\extracolsep{\fill}} *{6}{c} }
\toprule
    Language & Level & Current & Project
    & Paradigm /& Metering & Turing\\ 
    & & state & & influence & & completeness\\
\midrule
\endhead

\midrule[\heavyrulewidth]
\multicolumn{7}{r}{\textit{продолжение}}\\
\endfoot  

\midrule[\heavyrulewidth]
%\insertTableNotes  % tell LaTeX where to insert the table-related notes
\endlastfoot

Bamboo & high-level & alpha & Ethereum & functional 
& \centering {gas system} & yes\\
& & (experimental) & & & &\\
\addlinespace

Bitcoin & low-level & under & Bitcoin & stack-based, 
& script size & no\\
Script & & development & & reverse-polish & &\\
\addlinespace

Chain-& high-level & stable & Hyperledger & general purpose & timeout & yes\\
code & & & Fabric & languages & &\\
\addlinespace

EOSIO & high-level& stable & {EOS.IO} & object-oriented, & bound & yes\\
& & & & statically typed & system &\\    
\addlinespace

EVM & low-level& stable & Ethereum & stack-based & \centering gas system & yes\\
bytecode & & & & & &\\
\addlinespace

Flint & high-level & alpha & Ethereum & type safe, & {\centering gas system} & yes\\
& & & & contract-oriented& &\\
\addlinespace

IELE & low-level & prototype & Ethereum & register- & gas system & yes\\
& & & & based & &\\
\addlinespace

Ivy & high-level& prototype & Bitcoin & imperative & gas system & no\\
& & (experimental) & & & & \\
\addlinespace

Liquidity & high-level & under & Tezos & fully-typed, & gas system & yes\\
& & development & & functional & & \\
\addlinespace

LLL & intermediate-& under & Ethereum & stack-based & gas system & yes\\
& level & development & & & & \\
\addlinespace

Logikon & high-level & experimental & Ethereum & logical- & gas system & yes\\
& & & & functional & & \\
\addlinespace

Michelson & low-level & under & Tezos & stack-based, & gas system & yes\\
& & development & & strongly typed & & \\
\addlinespace

Plutus & high-level & under & Cardano & functional & gas system & yes\\
(PlutusCore) & (low-level) & development & & & & \\
\addlinespace

Rholang & high-level& under & RChain & functional & rule reduction & yes\\
& & development & & & system & \\
\addlinespace

Scilla & intermediate-& under & Zilliqa & functional & gas system & no\\
& level & development & & & & \\
\addlinespace

Simplicity & low-level & under & Bitcoin & functional, typed, & Bit Machine & no \\
& & development & & combinator-based & & \\
\addlinespace

Solidity & high-level & stable & Ethereum & statically typed, & gas system & yes\\
& & & & object-oriented & & \\
\addlinespace

SolidityX & high-level & beta & Ethereum & secure- & gas system & yes\\
& & & & oriented & & \\
\addlinespace

Vyper & high-level & beta & Ethereum & imperative & gas system & no\\
& & & & & & \\
\addlinespace

Yul & intermediate-& under & Ethereum & object-oriented & gas system & yes \\
& level & development & & & & \\
\addlinespace

\end{longtable}   
\end{ThreePartTable}

Было выявлено, что \name{Ethereum} является наиболее популярной платформой для работы со смарт-контрактами.
Экосистема данного блокчейна развита --- существует множество языков с различными подходами, сред разработки и статических анализаторов.
Аналогичной экосистемы нет ни у одного из всех рассмотренных блокчейнов.

\subsubsection{\name{Ethereum Virtual Machine}}
% https://habr.com/ru/post/340928/
\name{Ethereum Virtual Machine} (сокращенно \name{EVM}) --- Тьюринг-полная виртуальная стековая машина блокчейна \name{Ethereum}.
Смарт-контракты для этой платформы написаны на байткоде~\cite{EthereumYellowPaper}.
Под эту среду исполнения смарт-контрактов существует множество языков ~\cite{Bamboo, Flint, IELE, Logikon, Solidity, SolidityX, Vyper, LLL, Yul}, которые компилируются в байткод \name{EVM}.

Есть два участка памяти, куда \name{EVM} может записывать значения во время выполнения кода смарт-контракта --- \emph{memory} и \emph{storage}.
Memory является временным хранилищем данных, необходимым для записи промежуточных значений. 
Можно провести аналогию, что memory для \name{EVM} --- это как оперативная память для компьютера.
Ячейки memory адресуются от 0 до $2^{256} - 1$ (по размеру машинного слова \name{EVM} в 256 битов) и содержат байт информации.
Storage представляет из себя хранилище пар вида ключ-значение, которые описывают текущее состояние переменных смарт-контракта.
В отличие от memory, данные storage записываются в блокчейн.
Размер storage равен $2^{256}$ ячеек, каждая из них хранит машинное слово.

Аккаунты в блокчейн сети \name{Ethereum} бывают двух видов: \emph{пользовательские} и \emph{контракты}.
Аккаунты-контракты содержат код, который может быть вызван пользовательским аккаунтом или кодом другого контракта.

\subsubsection{\name{Hyperledger Burrow}}
\name{Hyperledger Burrow}~\cite{HLBurrow} --- проект, написанный на языке \name{Go}, который реализует приватный блокчейн с возможностью выполнения смарт-контрактов.
Ключевые особенности проекта: алгоритм консенсуса \name{Ten\-der\-mint}~\cite{Tendermint}, наличие программного интерфейса для удаленного вызова процедур, возможность выставлять права доступа к данным и на выполнение операций внутри сети, а также виртуальная машина для смарт-контрактов, написанных на байткоде \name{EVM}.


\subsection{\name{Hyperledger Iroha}}
\name{Hyperledger Iroha}~\cite{iroha} --- это приватный блокчейн, обладающий функциональностью для управления активами и сущностями, вводимые пользователями.
В нем используется алгоритм консенсуса \name{YAC}~\cite{YAC}, который основан на решении задачи о византийских генералах.
Данный фреймворк для распределенных хранилищ ориентирован на использование на мобильных устройствах.
Проект написан на языке \name{C++} с использованием библиотек \name{Boost}, \name{Protobuf}, \name{GTest} и множества других.
В качестве хранилища истории блокчейна сети используется локальная для каждого участника база данных \name{PostgreSQL}.

Как и во многих блокчейн сетях, пользователи \name{Hyperledger Iroha} выполняют различные действия с помощью транзакций, которые формируются из набора специальных команд.
Используя их, участники могут пересылать активы и управлять правами доступа (например, создать новую сущность или передать право владением активом другому участнику).

Прежде чем принять транзакцию, всем участникам сети нужно подтвердить её корректность.
Есть два этапа валидации --- \emph{stateless} и \emph{sta\-te\-ful}.
Команды должны быть сформированы согласно некоторым правилам.
Во время stateless валидации контролируется соответствие этим правилам.
Далее проводится stateful валидация. 
На этом этапе проверяется выполнимость отправленной транзакции (например, права доступа или наличие активов).