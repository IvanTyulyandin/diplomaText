\section{Специализация алгоритма Витерби}
В этой главе описаны подходы, которые были применены для 
специализации алгоритма Витерби.

\subsection{Специализация для GPGPU}
Основой для подхода послужила статья А.В. Тюрина, 
С.В. Григорьева и Д.А. Березуна ~\cite{part_eval_GPU}, 
в которой авторы специализировали наивный поиск подстроки в 
строке на GPGPU.
Согласно этой статье, специализация дала прирост 
производительности до 8 раз.
Такому результату дано следующее объяснение.
У большинства GPGPU, как и у CPU, есть кэш данных и 
кэш кода для ускорения доступа к информации.
Во многих случаях при обработке данных на GPGPU
объем данных гораздо больше объема кэша данных,
а код занимает небольшое количество памяти.
Идея специализации под GPGPU состоит в том, 
чтобы перенести статические данные в код программы.
При выполнении специализированной программы ожидается, 
что будет меньше промахов кэша данных, так как статические 
данные будут в кэше кода.

\subsubsection{Реализация}
Для исследования этого подхода был реализован специализатор с 
использованием стандарта \name{OpenCL} версии 
1.2~\cite{OpenCL_spec}.
Такой выбор обусловлен открытостью стандарта и поддержкой 
многими производителями GPGPU.
Специализатор обрабатывает модели \name{P7Viterbi},
описанные в параграфе \ref{HMM_solution}.
В код, предназначенный для выполнения на GPGPU, 
явно прописывались константы с помощью опции компилятора 
\name{OpenCL} \emph{-D}, 
которые можно взять из статических данных в \name{P7Viterbi}.
Код доступен по ссылке
\href{https://github.com/IvanTyulyandin/HMM_FASTA_Viterbi/
tree/open_cl}{github.com/IvanTyulyandin/HMM\_FASTA\_Viterbi}
в ветке open\_cl.

\subsection{Специализация алгоритма в терминах линейной алгебры}
В статье Э. Теодосиса и П. Марагоса~\cite{LA_Viterbi} описан 
вариант представления алгоритма Витерби через матричные 
операции.
Он предназначен для работы со СММ из раздела 
\ref{HMM_Vit} и рассмотрен в параграфе 
\ref{LA_Viterbi_review}.

Рассмотрим операции алгоритма и выделим те части, 
которые можно специализировать.
Начальный шаг --- это обработка первого события из 
последовательности событий \emph{O}.
\[Probs_{1} = P(O[1]) \times Pr\_b\]
В СММ записано множество наблюдаемых событий \emph{Obs}.
Матрицы $P(o)$ с преобразованными вероятностями для каждого 
события $o$ и столбец преобразованных вероятностей 
\emph{Pr\_b} состояний быть начальным могут быть 
получены из данных СММ.
Следовательно, можно заранее вычислить всевозможные варианты 
столбца $Probs_{1}$. 
Далее обрабатывается оставшаяся часть последовательности 
\emph{O}.
\[Probs_{t} = P(O[t]) \times Tr^{T} \times Probs_{t - 1}\]
Матрица переходов \emph{Tr} хранится в СММ.
Это значит, что умножение матрицы $P(o)$ на $Tr^{T}$ также 
может быть посчитано.

Таким образом, при специализации алгоритма Витерби в 
терминах линейной алгебры возможно сокращение количества 
матричных операций почти в два раза в сравнении с 
неспециализированной версией.

\subsubsection{Реализация}
Матрицы, которые описывают СММ, во многих случаях можно 
считать разреженными, то есть количество не нулевых элементов 
гораздо меньше, чем элементов всего.
Для работы с разреженными матрицами сообществом был создан 
стандарт \name{GraphBLAS}~\cite{GraphBLAS}.
Для проведения экспериментов по специализации алгоритма 
Витерби в терминах линейной алгебры была взята библиотека 
\name{SuiteSparse:GraphBLAS}~\cite{SuiteSparse}, 
которая де-факто считается самой производительной и является 
референсной реализацией стандарта \name{GraphBLAS}.

Специализатор считывает СММ, выполняет умножения матриц, 
которые зависят от статических данных из СММ, и результаты 
сохраняет в памяти, создавая специализированную функцию.
Далее, при вызове этой функции в зависимости от наблюдаемых 
событий, подставляются предпосчитанные матрицы.
Исходный код этого специализатора доступен по ссылке 
\href{https://github.com/IvanTyulyandin/Lin_alg_Viterbi}
{github.com/IvanTyulyandin/Lin\_alg\_Viterbi}.