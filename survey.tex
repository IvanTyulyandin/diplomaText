\section{Обзор}
В разделе сделан обзор предметной области.
Описаны скрытые марковские модели и алгоритм Витерби для работы с ними.
Приведены существующие проекты, решающие задачу гомологичности с применением скрытых марковских моделей.
Дано определение специализации.


\subsection{СММ и алгоритм Витерби}
\label{HMM_Vit}
\emph{Скрытая марковская модель}~\cite{Eddy_CHMM} (СММ) 
является дискретным вероятностным автоматом.
Модель имеет следующие параметры: множество состояний $St_{1..N}$, 
каждое из которых может создать событие из множества
$Obs_{1..K}$, вероятности $Pr\_b_{1..N}$ состояний быть
начальными, матрица $Tr$ вероятностей переходов между состояниями размера $N
\times N$ и матрица $Em$ вероятностей наблюдения события в определённом 
состоянии размера ${N \times K}$.

\emph{Алгоритм Витерби}~\cite{Viterbi}
(листинг~\ref{Viterbi}) считает вероятность нахождения в 
каждом состоянии СММ при условии того, что мы наблюдали последовательность событий \emph{O}.

\begin{lstlisting}[caption=Псевдокод алгоритма Витерби, label=Viterbi, escapeinside={(*}{*)}]
function Viterbi(St, Obs, Pr_b, Tr, Em, O)
	T = length(O)
	Dp[T][N]

	for j = 1..N
		Dp[1][j] = Pr_b[j] * Em[j][O[1]]
	
	for i = 2..T
		for j = 1..N
			Dp[i][j] = 
					(*$\max_{x = 1..N}$*)(Dp[i-1][x] * Tr[x][j] * Em[j][O[i]])

	return Dp[T]
\end{lstlisting}


\subsubsection{Алгоритм Витерби в терминах линейной алгебры}
Алгоритм Витерби выражается в терминах матричных 
операций из линейной алгебры~\cite{LA_Viterbi}.
Таким образом, этот алгоритм может быть реализован с 
использованием высокопроизводительных библиотек линейной 
алгебры, таких как
\name{SuiteSparse:GraphBLAS}~\cite{SuiteSparse}.

Ключевой идеей является определение специальной 
алгебраической структуры полукольцо \emph{Min\_plus} 
с операциями поэлементного сложения и умножения.
Элементы полукольца будут описывать вероятности в матрицах с
помощью дробных чисел.
Операция сложения имеет семантику взятия 
минимума из двух чисел, операция умножения --- семантику 
сложения чисел.
Нейтральным элементом по сложению будет $+\infty$, 
а по умножению 0.
Ниже приведен пример умножения матрицы на столбец 
с использованием полукольца \emph{Min\_plus}.
\[
  \begin{pmatrix}
    0 & 1 \\
    +\infty & 2
  \end{pmatrix}
  \begin{pmatrix}
    3 \\
    4
  \end{pmatrix}
  =
  \begin{pmatrix}
    min(0 + 3, 1 + 4) \\
    min(+\infty + 3, 2 + 4)
  \end{pmatrix}
  =
  \begin{pmatrix}
    3 \\
    6
  \end{pmatrix}
\]

Ко всем вероятностям в СММ применяется следующее
преобразование: отрицательный двоичный логарифм 
исходной вероятности.
Например, вероятность 0.5
будет представлена как $-1 * log_2(0.5) = 1$.
Это делается для сохранения точности расчетов.
Далее такая вероятность будет называться \emph{преобразованной}.

Для каждого события \emph{o} из множества \emph{Obs} 
определяем диагональную матрицу $P(o)$ размера $N \times N$.
Выражение $p_s(o)$ обозначает преобразованную вероятность наблюдать событие \emph{o} в состоянии \emph{s}.
\[
  P(o) =
  \begin{pmatrix}
    p_{1}(o) & \hdots & +\infty \\
    \vdots & \ddots & \vdots\\
    +\infty & \hdots & p_{N}(o)
  \end{pmatrix}
\]
Начало алгоритма Витерби --- это обработка первого события из 
последовательности \emph{O}.
В столбце \emph{Pr\_b} хранятся преобразованные вероятности 
состояний из СММ быть начальными.
Символ $\times$ обозначает умножение матриц с использованием 
полукольца \emph{Min\_plus}.
\[Probs_{1} = P(O[1]) \times Pr\_b\]
Далее вычисляются преобразованные вероятности для всех 
оставшихся событий из \emph{O}.
Матрица \emph{T} хранит преобразованные вероятности 
переходов из состояния в состояние:
\[Probs_{t} = P(O[t]) \times Tr^{T} \times Probs_{t - 1}\]
После выполнения всех шагов алгоритма, в столбце 
\emph{Probs\textsubscript{длина\_O}}
будут находиться преобразованные вероятности быть в 
определённом состоянии СММ при условии наблюдения 
последовательности событий \emph{O}.


\subsection{Задача гомологичности}
В этом подразделе рассмотрена задача гомологичности и способ её решения с 
использованием СММ.
Описано существующее программное обеспечение, которое решает задачу
гомологичности с помощью СММ.

\subsubsection{Формулировка}
В биологии для определения функциональности протеина, ищут общих эволюционных
предков с уже изученными протеинами.
Протеин состоит из 20 стандартных аминокислот, каждая из которых кодируется 
с помощью четырех нуклеотидов: аденозин~(A), тимин~(T), цитозин~(C) и 
гуанин~(G).
Для кодирования аминокислоты нужно три нуклеотида, которые могут повторяться.
Таким образом, возможно 64 варианта кодировки.
Часть аминокислот кодируется несколькими комбинациями нуклеотидов.
С некоторой вероятностью аминокислоты могут заменять друг друга в протеине.

Каждая аминокислота обозначается буквой латинского алфавита, что позволяет 
построить символьную последовательность, которая описывает протеин.
Сходство последовательностей является доказательством наличия общего предка у 
исследуемых протеинов, то есть гомологогичности.
Из-за вариативности кодировки и возможной замены 
аминокислот недостаточно посимвольного совпадения частей 
последовательности.
Для решения задачи гомологичности используется математическая модель, которая учитывает все необходимые вероятности.

\subsubsection{Решение с использованием СММ}
\label{HMM_solution}
Набор гомологичных протеинов может быть объединен в профиль 
семейства в виде СММ со специальной структурой и некоторыми 
изменениями в определении~\cite{HMM_Eddy}.
Эта СММ описывает общие подпоследовательности семейства, 
а события определяют символы аминокислот.
(рис.~\ref{HMM_example}).
\begin{figure}[b]
  \centering
  \includegraphics[width=\columnwidth]{HMM.png}
  \caption{Пример скрытой марковской модели \name{P7Viterbi}, описывающей 
	профиль семейства протеинов~\cite{MSV_Eddy}}
  \label{HMM_example}
\end{figure}
Такие модели называются \name{P7Viterbi}.
В сравнении с определением, использованном в \ref{HMM_Vit},
не все состояния могут создавать события.
Рёбра переходов между состояниями помечены весами, 
а не вероятностями.

Модели \name{P7Viterbi} имеют следующую структуру.
Состояния с префиксом M содержат информацию о совпадающих аминокислотах 
семейства на определённых позициях.
Состояния с префиксом D позволяют имитировать отсутствие аминокислот у 
некоторых протеинов семейства в конкретных местах.
Состояния с префиксом I учитывают возможность произвольного количества 
вставок аминокислот.
Дополнительные состояния N, J и C моделируют негомологичные участки протеинов в 
начале, середине и конце соответственно.
Состояние S стартовое, B символизирует о начале обработки гомологичного участка, E 
--- о конце этого участка, и T является завершающим состоянием.
Состояния, отмеченные кругом, не создают наблюдений. 

Алгоритм проверки гомологичности принимает на вход 
исследуемый протеин и профиль семейства.
Далее выполняется алгоритм Витерби для определения наиболее 
вероятных состояний СММ с учетом наблюдаемой символьной 
последовательности исследуемого протеина.
В его реализации учтена разница определений СММ, о которой 
писалось выше.
Результатом работы является оценка гомологичности протеина 
и семейства, заданного с помощью \name{P7Viterbi}.

\subsubsection{\name{HMMer}}
\name{HMMer}~\cite{HMMer} используется для поиска в базах данных 
последовательностей гомологов исследуемых протеинов, а также для создания 
профилей семейств протеинов.
Это проект с открытым исходным кодом.
Написан на языке \name{C} с возможностью использовать \name{SIMD} инструкции 
процессора.
Применяется во многих базах данных, таких как \name{Pfam}~\cite{Pfam}.

Авторами проекта были предложены вероятностные фильтры, которые используют 
\name{P7Viterbi} с частью удалённых состояний.
Применение фильтров позволяет ускорить обработку данных за счет уменьшения
вычислений в алгоритме Витерби.
Один из таких фильтров --- \name{MSV} (Multiple Segment 
Viterbi)~\cite{MSV_Eddy}.
Он моделирует последовательность из одной или более частей, 
внутри которых аминокислоты не могут быть удалены или 
вставлены.
Соответственно, веса перехода в состояния с префиксами D и I 
считаются нулевыми (рис.~\ref{MSV_example}).
\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{MSV.png}
  \caption{Пример СММ вероятностного фильтра MSV~\cite{MSV_Eddy}}
  \label{MSV_example}
\end{figure}

\subsubsection{\name{CUDAMPF}}
В проекте \name{CUDAMPF}~\cite{cudampf} запрограммированы вероятностные фильтры из 
\name{HMMer} с использованием \name{CUDA}.
Код предназначен для видеокарты \name{NVIDIA} \name{Tesla K40} архитектуры
\name{Kepler}.
Проект рассчитан на определение гомологичности одновременно для множества 
протеинов.

Авторы предлагают четыре уровня параллелизма.
Первые три основаны на логическом параллелизме по данным.
Четвертый уровень использует \name{SIMD} инструкции вычислителей видеокарты.
Разделение данных по уровням позволило добиться ускорения в 23,1 раз при работе 
с фильтром \name{MSV} и в 11,6 раз с \name{P7Viterbi} по сравнению с
\name{HMMer}.

Несмотря на то, что авторами заявлена корректность реализации, в коде некорректно
вычисляется состояние E при обработке \name{P7Viterbi} и \name{MSV}.
Для этого состояния необходимо искать максимум на текущем шаге из состояний с 
префиксом M.
В исходном коде \name{CUDAMPF} переменная, хранящая максимум, 
не защищена от одновременной записи двумя или более потоками.

\subsection{Специализация}
При имеющейся программе $P$ и всех её входных параметрах 
$in$, можно получить результат выполнения $P$ на $in$.
При наличии только части параметров $in_1$ из $in$, 
\emph{специализатор} должен выполнить
вычисления и оптимизации кода в $P$, зависящие от $in_1$, 
а затем сгенерировать программу $P_{in1}$, 
которая будет принимать оставшиеся параметры $in_2$ и 
выполнять последующие вычисления (рис. \ref{spec}).
Параметры $in_1$ называются статическими, 
а $in_2$ --- динамическими.
Результат выполнения $P_{in1}$ на $in_2$ должен быть равен 
результату выполнения $P$ с параметрами $in$.
Ожидается, что специализированная программа будет 
производительнее неспециализированной версии за счет 
уменьшения вычислений или более оптимального использования 
оборудования, на котором выполняется программа.
Распространённой проблемой на практике является замедление 
производительности $P_{in1}$ из-за большого объема 
сгенерированного кода.
\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{spec.png}
  \caption{Специализация~\cite{Jones_spec}}
  \label{spec}
\end{figure}

Специализация была успешно применена в обработке 
графики~\cite{RT_spec}, обработке запросов к базам 
данных~\cite{SQL_spec} и поиску подстроки в строке на 
GPGPU~\cite{part_eval_GPU}.
Более подробно о специализации можно узнать в книге Джонса, 
Гомарда и Сестофта \cite{Jones_spec}.